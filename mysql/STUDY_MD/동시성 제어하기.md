# 동시성 제어하기

## 동시성

- 대부분 하나의 웹 서버는 여러 개의 요청을 동시에 수행할 수 있다.
- 바꿔서 얘기하면 **작성한 코드 한줄은 동시에 수행될 수 있다.**
    - 데이터 정합성을 깨뜨릴 수 있다.
        - DB 하나의 레코드, 또는 서버의 글로벌 변수


- e.x. 100원을 출금하는 요청이 동시에 발생한다면

```text
TX1 
READ(홍길동 잔고) -> 1000
UPDATE(홍길동 잔고 -100) -> 900

TX 2 
READ(홍길동 잔고) -> 1000

- TX1 UPDATE 커밋 전이라 1000원에서 900 원을 업데이트 진행 
UPDATE(홍길동 잔고 -100) -> 900
```

### 데이터베이스에서 동시성 이슈가 발생하는 일반적인 패턴

1. 공유자원 조회
    - 다른 오퍼레이션 수행
2. 공유자원 갱신

#### 이런 이슈들을 어떻게 제어할 수있을까? (보편적인 방법)

- **공유 자원에 대한 잠금을 획득하여 줄 세우기**

### 동시성 이슈가 어려운 이유

1. 로컬에서는 대부분 하나의 스레드로 테스트
2. 이슈가 발생하더라도 **오류가 발생하지 않는다**
3. 코드에서 잘 보이지 않는다.
4. 항상 발생하지 않고, 비결정적으로 발생한다.

> 동시성 이슈가 발생할 수 있거나 여지가 있는지 꼭 확인해봐야한다!
> **작성한 코드 한 줄은 동시에 수행 될 수 있다.**
> 지금은 MySQL 강의라서 MySQL에 초점을 맞추지만, 애플리케이션 단에서도 발생할 수 있다!

## 쓰기락과 읽기락

- 보편적인 방법은 공유 자원에 대한 잠금을 획득하여 줄 세우기 이다

- 락을 통해 동시성을 제어할 때는, **락의 범위를 최소화 하는 것이 중요**
- 스프링을 사용하면 락의 범위가 길어질 수록 커넥션을 점유하는 시간이 길어져서 커넥션 풀 고갈이 발생할 수 있다. 조심!

### MySQL의 락

- MySQL에서는 **트랜잭션의 커밋 혹은 롤백 시점에 잠금이 풀린다!**
    - -> **트랜잭션이 곧 락의 범위**
        - 그래서 S3 같이 외부 에서 사용되는 부분은 트랜잭션에서 제외 시켜주는 것이 좋다!
- MySQL에서는 **쓰기락, 읽기락 두 가지 잠금을 제공!**

|                      | 읽기 락 (Shared Lock) | 쓰기 락(Exclusive Lock) |
|----------------------|--------------------|----------------------|
| 읽기 락 (Shared Lock)   | O                  | 대기                   |
| 쓰기 락(Exclusive Lock) | 대기                 | 대기                   |

- 읽기락 끼리는 잠금을 공유 가능! 
- 반면에 쓰기락은 베타적이라서 읽기락이 걸려있든 쓰기락이 걸려있든 무조건 대기를 발생함! 

- 읽기락은 `SELECT .... FOR SHARE`
- 쓰기락은 `SELECT .... FOR UPDATE 또는 UPDATE, DELETE 쿼리`

- 매번 잠금이 발생할경우, 성능 저하를 피할 수 없음 
  - **MySQL에서 일반 SELECT는 nonblocking consistent read로 동작 (대기없는 읽기!)**
  - Undo Log를 가지고 있어서 가능한 것!
- ** MySQL에서 잠금은(레코드 락) row가 아니라 인덱스를 잠근다!**
  - -> 인덱스가 없는 조건으로 **Locking Read시 불필요한 데이터들이 잠길 수 있음**

---
#### MySQL 락 실습

```sql
select * from POST where memberId = 3 and contents = 'string';

start transaction;
select * from POST where memberId = 3 and contents = 'string' for update;

select * from information_schema.innodb_trx; # 현재 트랜잭션이 실행되어 있는지 확인
select * from performance_schema.data_locks; # 현재 어떤 레코드에 락이 잡혀 있는지 확인 Lock_mode가 X 라면 잠긴 것 근데 다른 레코드도 락이 잠김 (memberId 3의 데이터가 4건이라서 모든 데이터가 락에 걸림)
```

- 트랜잭션을 닫지 않은 상태로 
- 다른 세션의 콘솔을 열고 
- `select * from POST where memberId = 3 and contents = '다른내용' for update;` 을 실행 시켜보자!
- where 문에 있는 memberId와 contents가 검색되고 막히는데 contents는 인덱스 처리가 안되어 있어서 **memberId =3 에 해당하는 모든 게시물에 락이 걸린다!**
- 이에 따라 `where createdDate='2024-04-06' for update` 로 쿼리를 실행하면 -> **모든 로우가 락이 걸린다!**

> MySQL에서 잠금은 row가 아니라 **인덱스를 잠근다**
> 
> -> **인덱스가 없는 조건으로 Locking Read시 불필요한 데이터들이 잠길 수 있다!**


### 추가로 공부해볼만 한 것들 
- Java에서의 동시성 이슈 제어 방법
- MSA등 분산환경에서의 동시성 이슈 제어 방법
- MySQL의 넥스트 키락이 등장한 배경 (row와 row 사이에 막아주는 겟락과 레코드 락이 합쳐진 것)
- MySQL 외래키로 인한 잠금
- MySQL 데드락 

