# 비관적 락  
- **동시성 제어를 위한 가장 보편적인 방법은 락을 통한 줄세우기** 
  - -> **비관적 락**
- 락을 통한 **동시성 제어는 불필요한 대기 상태를 만듬**
  - 동시성이 빈번하지 않은 쿼리로 인해 다른 쿼리가 대기한다면?

# 낙관적 락
- 동시성 이슈가 빈번하지 않길 기대하고, 어플리케이션에 제어한다. 
  - **CAS(compare and set)을 통해 제어** 
    - 업데이트 하기 전에 비교를 하고 맞으면 하고 그렇지 않으면 하지 않겠당 

- e.x. 아까 A 잔액 예시로 가보자
  - 버전이라는 필드가 추가
  
  | 이름  | 잔액   | 버전 |
  |-----|------|----|
  | 홍길동 | 1000 | 1  |

- TX 1
  - READ(홍길동 잔고) -> 1000, 1 

- TX 2 
  - READ(홍길동 잔고) -> 1000, 1

- TX 1 
  - UPDATE(홍길동 잔고 -100), (2) WHERE 버전 1 
  - //버전을 올려준다! 

- TX 2
  - UPDATE(홍길동 잔고 -100) WHERE 버전 1 <- 이 구문은 실패됨!

- 낙관적 락은 실패했을 때 재시도를 하든 노티를 하든 이런 전략을 직접 구현해야함 
- JPA 는 어노테이션으로 간단하게 구현 가능!