# 트랜잭션

## 트랜잭션이 왜 필요할까? 
- e.x. A 라는 사람은 1000원이 있고, B라는 사람이 500원이 있다고 하자 
- 만약 B라는 사람이 A 한테 돈을 600원 보낸다고 하자. 
- 처음에 A 한테 1000 + 600 원을 더하고 ,
- 다음에 B 의 돈에서 500 - 600 원을 하면 -100원이라서 실패 할 것이다. 

- 만약, 트랜잭션이 없다면 A는 1600원이 되고, B는 500원이 될 것

> 여러 SQL문을 마치 하나의 오퍼레이션으로 묶을 수 있어야 한다!

- 처리중인 데이터를 다른 곳에서 조회하게 되면 문제가 발생
  - 트랜잭션 격리레벨

## 트랜잭션 ACID 
- ACID(원자성, 일관성, 고립성, 지속성)은 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어
  - **원자성(Atimicity)** : 트랜잭션과 관련된 작업들이 **부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력**
  - **일관성(Consistency)** : 트랜잭션이 **실행을 성공적으로 완료**하면 -> **언제나 일관성 있는 데이터베이스 상태로 유지**하는 것
  - **독립성(Isolation)** : 트랜잭션을 수행시 **다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것**
    - 성능관련 이유로 인해서 **이 특성은 가장 유연성 있는 제약조건!**
  - **지속성(Durability)** : **성공적으로 수행된 트랜잭션은 영원히 반영되어야함**.


##### Atomicity - 원자적 연산을 보장해야한다.
-> All or Nothing (무조건 성공 또는 무조건 실패)
- MySQL은 어떻게 보장하냐? MVCC

- e.x. 트랜잭션 을 시작하고 A의 잔액을 1000원 증가 시키자 , 
  - 그럼 Mysql은 Undo Log에 기존의 값을 담아둔다 
  - 그리고 트랜잭션이 실패하면, -> Undo Log 데이터로 롤백한다.
  - 트랜잭션이 성공하더라도, Undo Log의 데이터를 바로 삭제하지는 않는다! 
---
- **트랜잭션이 Atomicity한 단위가 된다!**

##### Consistency - 트랜잭션이 종료되었을 때 데이터 무결성이 보장
제약조건을 통해 (e.x. 유니크 제약, 외래키 제약 등 )


##### Isolation - 트랜잭션은 서로 간섭하지 않고 독립적으로 동작한다 
- 하지만 많은 성능을 포기해야하므로 개발자가 제어가 가능
- 트랜잭션 격리레벨을 통해 via MVCC
- 지원하는 DB마다 조금씩 다르다!

##### Durability - 완료된 트랜잭션은 유실되지 않는다
- MySQL 아키텍처 파트에서 말했던 **WAL을 통해!** 
- DB에서 성능의 핵심은 Disk I/O 랜덤 부분을 줄이는 것! 
- 업데이트나 쓰기 작업할 때 밀어넣을 때 마다 Disk에 작성하면 느려진다.
- 그래서 메모리에 일차 저장함 하지만 메모리는 휘발성이 있어서 위험하니까 
  - WAL을 활용해서 (순차적으로 로그를 쌓음) 속도를 빠르게 함
    - 만약 재 시동했을 때 만약 저장하지 못한 데이터가 있으면 WAL을 보고 처리한다.


## 트랜잭션 격리레벨 

##### Isolation - 트랜잭션은 서로 간섭하지 않고 독립적으로 동작한다 
- 하지만 많은 성능을 포기해야하므로 개발자가 제어가 가능

---
- innoDB 기준으로 설명!

1. READ UNCOMMITTED
2. READ COMMITTED
3. REPEATABLE READ
4. SERIALIZABLE READ

- 아래 3가지 이상중에 결정이됨!
1. Dirty Read
2. Non-Repeatable Read
3. Phantom READ

이 중 몇가지를 허용하냐에 따라 격리 레벨이 결정이됨!

---
e.x. A가 B 에게 900원을 송금 
- 두 트랜잭션 (TX1, TX2 가 비슷한 시간에 접근했다고 정의하자!)

| 이름 | 잔액   |
|----|------|
| A  | 1000 |
| B  | 500  |


### Dirty Read
- **커밋되지 않은 데이터를 읽었다.**

TX1

- READ (A 잔고) => 1000
- UPDATE (B 잔액) => 1400 <- 여기서 실패! 
- 다시 500원으로 되돌려짐 

TX2 
- TX1의 UPDATE 되었을 때의 잔액을 읽어감  
- READ(김국밥) -> 1400

### Non-Repeatable Read
- **하나의 트랜잭션에서 같은 데이터를 읽었을 때 다른 데이터가 나올때**
- **같은 데이터를 읽었는데 값이 달라지는 것!**

TX1
- READ(홍길동 잔고) -> 1000

TX2 
- UPDATE (홍길동 잔고) -> 1200
- 커밋전!

TX1
- READ(홍길동 잔고) -> 1000

TX2
- UPDATE SQL 커밋!

TX1
- READ(홍길동 잔고) -> 1200

### Phantom Read
- 같은 조건으로 데이터를 읽었을 때 없던 데이터나 생기거나 있던 데이터가 없어지는 현상 

TX1 
- Read(1000원 보다 많은 잔고) -> 홍길동 

TX2
- UPDATE(김국밥) -> 1200
- COMMIT
ex ) insert, delete 도 있을 수있음 
TX1
- Read(1000원 보다 많은 잔고) -> 홍길동, 김국밥


---
### 격리레벨은 위 세가지 현상중 얼마나 허용할 것인가에 따라서 결정된다! 

|                   | **Dirty Read** | **Non Repeatable Read** | **Phantom Read** |
|-------------------|----------------|-------------------------|------------------|
| Read Uncommitted  | O              | O                       | O                |
| Read Committed    | X              | O                       | O                |
| Repeatable Read   | X              | X                       | O                |
| Serializable Read | X              | X                       | X                |

- 이 격리 레벨은 4가지 지만, 여기서 어떤 현상을 없애주는지에 따라 이해하는게 좋음!
- **아래로 갈 수록 동시처리량이 낮아진다!**
- **보통 READ COMMITTED 또는 REPEATABLE READ 를 쓰는데** 
  - **REPEATABLE READ는 데드락 현상이 발생해서 보통 READ COMMITTED 를 많이 쓰는 것 같다**
  - 