# 읽기와 쓰기의 트레이드 오프

## 좋아요 구현
1. 게시물 컬럼 추가를 통한 구현 - 비관적 락
2. 게시물 컬럼 추가를 통한 구현 - 낙관적 락
3. 좋아요 테이블 추가를 통한 구현 

---
### 컬럼을 통한 구현 
1. 조회시 컬럼만 읽어오면 됨
2. 쓰기시 게시물 레코드에 대한 경합이 발생 
    -  -> 하나의 자원(게시물)을 두고 락 대기가 발생 
    - 동시성이슈가 빈번해서 낙관적락으로도 힘듬
3. 같은 회원이 하나에 게시물에 대해 여러번 좋아요를 누를 수 있음

### 테이블을 통한 구현 
1. 조회시 매번 count 쿼리 연산
2. 장점 쓰기시 경합없이 인서트만 발생
3. 장점 회원정보 등 다양한 정보 저장 가능

- 하지만 조회시 매번 count 쿼리가 발생한 것은 매우 큰 부하!

#### 병목 해소하기 
- 쓰기 지점은 병목은 하나의 레코드를 점유
  - 이를 해결하기 위해서 테이블로 분리
- 조회 지점의 병목은 카운트 쿼리 

- **좋아요 수는 높은 정합성을 요구하는 데이터인가?**
  - 1초 등 딜레이를 보여줘도 되나? 
  - 100% 정확한 시간을 돌려줄 필요가 없다!

![eliminate-bottleneck.png](..%2FIMAGE%2Feliminate-bottleneck.png)
- 좋아요 테이블에 insert 하고 
- 특정 주기마다 도는 스케쥴러가 좋아요 테이블을 count 해서 
- 이 데이터를 게시물 테이블에 좋아요 수를 update 해줌! 
- 1초에 10만번 100만번 오는 게시물이 있어도, 
- 이 주기마다 한번씩 count가 나와도 괜찮다

- 단점 : 이 버전에서는 웹 서버 뿐만 아니라 스케쥴러도 관리해줘야함!
  - 고객은 계속해서 잘못된 데이터를 보게 됨 
  - 시스템 복잡도가 올라감
  - 좀더 나아가서 게시물 테이블에 update를 하는데 
    - 이때 redis를 쓰는 것도 좋다 
    - redis로 관리하는 것도 좋다! 

- 내가 누른 좋아요가 곧 바로 반영이 될까? 
  - 이런 것도 클라이언트 캐싱을 해서 고객이 좋아요 하는 것을 +1 해주는 방식도 있다.

> 데이터의 성질, 병목지점등을 파악하고, 적당한 기술들을 도입해 해소!


## 추가 작업 사항 
- Repository Layer를 Jpa로 리팩토링
- 팔로워가 100만명인 유저의 게시물 작성 성능 테스트
  - 비동기 큐를 통해 개선
  - Mixed Push /Pull Model
- 로그인/ 팔로우 승인, 취소, 댓글 구현
- MySQL Master / Slave
- 파티셔닝 

