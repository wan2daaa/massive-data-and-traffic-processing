# 타임라인

## 타임라인이란
- a.k.a. 뉴스피드
- 트위터, 페이스북, 인스타그램 등 SNS에서 팔로워들의 게시물을 보여주는 피드 

### 서비스가 커질수록 느려지는 타임라인

#### 타임라인 구현 흐름 
1. 회원의 팔로우 목록 조회
2. 1번의 팔로우 회원 id로 게시물 조회

#### 타임라인 구현의 시간 복잡도 
- `log(Follow 전체 레코드)`
- `+` 
- `해당 회원의 팔로잉수 * log(Post 전체 레코드)`
  - 각 회원의 게시물테이블에 접근하여 전체 게시물을 반환해줌 
  - 팔로잉하는 회원들은 모두 or 이라서 -> 
    - 해당 회원의 Following 수만큼 Post를 전체 레코드를 반복해서 읽음
  
  
- 해당 회원의 팔로우들를 찾아서 모든 팔로우들의 Post를 각각 Post테이블을 스캔해야함 
  - **팔로잉 수가 많을 수록 부하가 엄청 걸림!**

- 위 방식을 `Fan Out On Read(Pull Model) 방식` 
  - 사용자가 매번 홈에 접속할 때마다 부하가 발생! 
 
>  우리가 구현한 **이 플로우의 시간 복잡도를 구할 수 있고**, 그에 따른 병목이 생기는 부분을 캐치하자!

## Fan Out On Write(Push Model)
- 게시물 작성시, 해당 회원을 팔로우하는 회원들에게 데이터를 배달한다. 

- e.x. 
  - 3번유저가 게시물을 작성하면 나를 팔로우하는 유저를 찾고, 
  - 타임라인 테이블에 게시물id와 전달할 멤버의id를 넣어준다 

### 타임라인 조회시에는 Timeline 테이블을 조회하여 게시물들을 조회 
- Pull 모델에서의 조회시점의 부하를 **쓰기시점의 부하로 치환**

---

- fackBook 은 PULL Model을 사용하고,
- twitter는 PUSH Model을 사용! 


---
# 타임라인 최적화 

## 정합성과 성능의 트레이드 오프
- Push Model은 공간복잡도를 희생, Pull Model은 시간 복잡도를 희생
- Push Model vs Pull Model 중 어떤 것이 정합성을 보장하기 쉬울까?
  - Pull Model은 원본 데이터를 직접 참조하므로 , 정합성 보장에 유리 
    - 하지만 Followers수가 많을수록 처리 속도가 느리다.
      - FaceBook 은 Pull Model을 사용해서 최대 5000명의 친구만 보유할 수 있다.

---
- Push Model 에서는 **게시물 작성과 타임라인 배달의 정합성 보장에 대한 고민**이 필요하다!
- **모든 회원의 타임라인에 배달되기 전까지 게시물 작성의 트랜잭션을 유지하는 것이 맞을까?**
  - CAP 이론 //추가 공부 필요
- Push Model은 Pull Model에 비해 시스템 복잡도가 높다
  - **하지만 그만큼 비즈니스, 기술 측면에서 유연성을 확보시켜준다!**

> **결국 은총알은 없다.**
> 
> 상황, 자원, 정책등 여러가지를 고려해 트레이드 오프 해야한다!