# 조회 최적화를 위한 인덱스 이해하기 

- 인덱스는 **정렬된 자료구조** -> 이를 통해 **탐색범위를 최소화**


e.x. 이런 테이블이 있다.

| 데이터 주소 | 이름  | 성별 | 나이 | 직업  |
|--------|-----|----|----|-----|
| 1      | 박재완 | 남  | 27 | 백엔드 |
| 2      | 정경주 | 여  | 25 | 프론트 |
| 3      | 홍길동 | 남  | 19 | 어부  |
| 4      | 김철수 | 남  | 45 | 개발자 |

- 여기서 나이가 가장 어린 사람을 찾고 싶으면?
  - 첫번째 박재완을 보고 27을 기억하고
  - 그다음 25가 더 낮으니까 25를 기억하고
  - 그다음 19가 더 낮으니까 19를 기억하고
  - 그다음 45가 더 크니까 19를 준다.
- **전체 데이터를 다 봐야함**
- 인덱스가 있다면? 

나이 인덱스가 있을 때

| 나이 | 데이터 주소 |
|----|--------|
| 19 | 3      |
| 25 | 2      |
| 27 | 3      |
| 45 | 4      |

- 데이터가 나이순으로 정렬되어 있어서 하나만 조회하면됨

---
## 인덱스란 
- **인덱스도 테이블이다!**
- 인덱스는 **정렬된 자료구조** -> 이를 통해 **탐색범위를 최소화**
- 인덱스의 핵심은 **탐색(검색) 범위를 최소화 하는 것**



### 검색이 빠른 자료구조들은 어떤 것이 있을까?
- Hash Map, List, Binary Search Tree...


- **HashMap**
  - 단건 검색 속도 O(1)
  - 그러나 범위 탐색은 O(N)
  - 전방 일치 탐색 불가 e.x. `like 'AB%'`


- **List**
  - 정렬되지 않은 리스트의 탐색은 O(N)
  - 정렬된 리스트의 탐색은 O(logN)
  - 정렬되지 않은 리스트의 정렬 시간 복잡도는 O(N) ~ O(NlogN)
  - 삽입/삭제 비용이 매우 높음 



# MySQL에서 사용하는 자료구조
- **Tree**
  - 트리 높이에 따라 시간 복잡도가 결정됨
  - **트리의 높이를 최소화**하는 것이 중요!
  - **한쪽으로 노드가 치우치지 않도록 균형을 잡아주는 트리 사용**
    - e.x. Red-Black Tree, B+ Tree

- **B+ Tree**
  - 삽입 / 삭제시 항상 균형을 이룸
  - 하나의 노드가 **여러 개의 자식 노드를 가질 수 있음**
  - 리프 노드에만 데이터 존재
    - 연속적인 데이터 접근 시 유리
  - **데이터를 삭제하거나 추가할 때 B+ Tree의 노드가 추가되거나 삭제 될 수 있으므로 추가/갱신의 속도를 늦춘다.**
    - **모든건 트레이드 오프다!**
![learn-b+tree.png](..%2FIMAGE%2Flearn-b%2Btree.png)

- Cherry를 찾고 싶다
- Durian 보다 작으니까 Apple이 가리키는 노드 주소로 이동
- Carrot 보다 크니까 Carrot이 가리키는 노드 주소로 이동
- Carrot이 가리키는 노드에서 Cherry의 PK 키를 찾고 PK 인덱스를 거쳐 데이터에 진입

# 클러스터 인덱스란? 
1. **데이터의 위치를 결정하는 키 값이다.**
2. **MySQL의 PK는 클러스터 인덱스다.**
3. **MySQL에서 PK를 제외한 모든 인덱스는 PK를 가지고 있다!**


### 클러스터 인덱스는 데이터 위치를 결정한다.

| 클러스터 키 | 데이터 주소 |
|--------|--------|
| 1      | A      |
| 2      | B      |
| 3      | C      |
| 5      | F      |

클러스터 키 4번이 Insert 된다면

| 클러스터 키 | 데이터 주소 |
|--------|--------|
| 1      | A      |
| 2      | B      |
| 3      | C      |
| 4      |        |
| 5      | F      |

->

| 클러스터 키 | 데이터 주소 |
|--------|--------|
| 1      | A      |
| 2      | B      |
| 3      | C      |
| 4      | D      |
| 5      | F      |


- 정렬된 순서에 따라서 데이터 저장 위치가 변경 된다!
- 데이터가 밀려서 성능이 이슈가 발생할 수있다.
  - -> **클러스터 키 삽입/갱신시에 성능이슈 발생**

### MySQL PK는 클러스터 인덱스 
- PK 순서에 따라서 데이터 저장 위치가 변경 된다!
  - -> PK 키 삽입/갱신시 성능 이슈 발생

###### PK로 Auto Increment vs UUID 장단점 찾아보기 

| 구분 | AutoIncrement                                                              | UUID                                                                          |
|----|----------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| 장점 | - 빠르다 <br/>- key를 한눈에 보기 쉽다.                                               | - UUID를 어디서든지 만들고 고유성을 보장할 수 있어 분산 시스템에 용이                                    |
| 단점 | - 분산 시스템에 적합하지 않다.(서로 다른 DB에 저장하는 key가 같은 데이터를 처리하기 힘듬)<br/>- 키를 예측하기 어렵다. | - 성능의 저하를 일으킨다.(클러스터 인덱스의 정렬 비용이 많이듬)<br/>- 사람이 보기 힘듬<br/>- 필요 이상으로 공간을 많이 차지 |

### 모든 인덱스는 PK를 가지고 있다. 
- MySQL에서 PK를 제외한 모든 인덱스는 PK를 가지고 있다.
- 인덱스를 만들 때마다 PK를 가지게 되는데,
  - PK의 사이즈가 인덱스의 사이즈를 결정
- (PK를 제외한 보조인덱스 )세컨더리 인덱스만으로는 데이터를 찾아갈 수없다. 세컨더리 인덱스 -> PK -> 데이터
  - -> PK 인덱스를 항상 검색해야함 


##### MySQL이 PK를 가지고 있는 이유
- PK가 클러스터 인덱스 이기 때문에 
  - PK가 업데이트 되거나 하면 데이터 주소가 바뀌게 때문
  - 데이터 순서를 가지고있으면 부하가 많이 되서 
  - 인덱스는 PK를 가지고 있고 부하가 덜함

## 클러스터 인덱스의 장점
1. **PK 를 활용한 검색이 빠름. 특히 범위 검색!**
   - 공간적 캐시 이점을 누릴 수 있음
2. **세컨더리 인덱스들이 PK를 가지고 있어 커버링에 유리**
   - 커버링 인덱스를 사용하면 테이블에 액세스하지 않고도 인덱스에서 쿼리의 모든 필요한 데이터를 찾을 수 있습니다
