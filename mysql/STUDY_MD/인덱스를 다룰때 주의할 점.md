# 인덱스를 다룰때 주의할점 
1. 인덱스 필드 가공
2. 복합 인덱스
3. 하나의 쿼리에는 하나의 인덱스만 
4. 인덱스를 설정할때는 카디널리티라고 하는 데이터의 식별 정도가 높은 것으로 하는게 좋다!

## 인덱스 필드 가공

```sql
# age는 int 타입
SELECT *
FROM Member
WHERE age* 10 = 1

SELECT *
FROM Member
WHERE age = '1'
```
- 이런 경우처럼 **인덱스 필드를 가공되면 인덱스를 사용 못함!**
- 또는 **타입을 잘못 넣어주면 인덱스를 사용 못함!**

## 복합 인덱스

- 복합 인덱스를 사용하게 되면
  - 1번째 인덱스 기준으로 정렬하고, 
  - 그다음 중복된 값은 2번째 인덱스 기준으로 정려하게된다.

- **선두컬럼을 어떤걸 정하는지가 중요하다!**

## 하나의 쿼리에는 하나의 인덱스!

- 하나의 쿼리에는 하나의 인덱스만 탄다.
- 여러 인덱스 테이블을 동시에 탐색하지 않음
  - index merge hint를 사용하면 가능하긴 하지만 
  - 기본적으로는 아니라고 생각해야함!

- WHERE, ORDER BY, GROUP BY 혼합해서 사용할 때는 
  - 사용할 때는 인덱스를 잘 고려해야함
- WHERE는 인덱스를 탔는데, ORDERBY 에서 못타면 결국 다시 정렬해야되서 속도가 느려질 것 

- 의도대로 인덱스가 동작하지 않을 수 있음. EXPLAIN으로 확인!
- **인덱스도 비용이다.** 쓰기를 희생하고 조회를 얻는 것!
- **꼭 인덱스로만 해결할 수 있는 문제인가 ?**
  - 사실 인덱스로 푸는게 제일 간단하지만, 
  - 조회 조건은 많이 바뀌게 됨 (정렬 조건)
    - 어느 순간에는 인덱스로 사용 안될 수 있고,
    - **조회와 쓰기 모델을 분리할 수있고**,
    - **캐시를 사용할 수 있다.**

## 인덱스를 설정할때는 카디널리티라고 하는 데이터의 식별 정도가 높은 것으로 하는게 좋다!
- 성별 : 남, 녀 결국 데이터를 절반밖에 못버림