# MySQL

## MySQL 을 학습해야하는이유
- 관계형 DB는 아직까지도 가장 범용적으로 사용되고, 
- 백엔드 개발자라면 아주 높은 확률로 관계형 데이터베이스를 실무에서 다룰 것
  - 그렇다고 다른 종류(DocumentDB, Graph DB ...)는 몰라도 되냐?
    - 알아야 한다.
    - 하지만 여러 종류의 DB는 서로의 문제를 보완하고 발전한 상호 보완적인 관계이기 때문에
    - 하나를 깊게 학습하면 다른 종류의 DB들도 쉽게 학습 가능 
- 관계형 DB에도 여러 DB가 있지만, 가장 인기가 많은 오픈소스 관계형 DB 이고,
- 높은 접근성과 낮은 비용
- 네이버, 카카오, 토스 등 대부분의 국내 IT 기업에서 가장 많이 사용 된다.
- SQL 안식 표준을 지키고 있다.


## MySQL 아키텍처
데이터 베이스도 결국 파일을 관리하는 하나의 서버이다!

- 서버는 SQL을 통해서 DB에게 요청한다. 

![mysql-inside.png](image%2Fmysql-inside.png)

- 서버가 전달한 SQl 요청을 Mysql 서버에서는 Mysql엔진, 스토리지엔진, 운영체제, 디스크를 거쳐 데이터를 전달해준다.

1. MySQL 엔진 : **판단과 명령을 하는 두뇌**
2. 스토리지 엔진 :**판단을 수행하는, 동작하는 팔과 다리**


![mysql-engine-inside.png](image%2Fmysql-engine-inside.png)

MySQL 엔진 안에는 크게 네가지로 나뉘어져 있다.
- **쿼리파서**
  - **SQL을 파싱**하여 **Syntax Tree**를 만든다
  - 이 과정에서 **문법 오류를 검사**한다.
- **전처리기**
  - 쿼리파서에서 만든 Tree를 바탕으로 전처리 시작
  - 테이블이나 컬럼 존재 여부, 접근 권한등 Semantic(의미론적) 오류 검사

- 쿼리파서, 전처리기는 컴파일 과정과 매우 유사하다
- 하지만 SQL은 프로그래밍 언어처럼 **컴파일 타임 때 검증 할 수 없어 매번 구문평가를 진행!**

- **옵티마이저** 
  - **쿼리를 처리하기 위한 여러 방법들**을 만들고, **각 방법들의 비용정보와 테이블의 통계정보를 이용해 비용을 산정**
  - 테이블 순서, 불필요한 조건 제거, 통계정보를 바탕으로 전략을 결정 (실행 계획 수립)
  - 옵티마이저가 어떤 전략을 결정하느냐에 따라 성능이 많이 달라진다.
  - **가끔씩 성능이 나쁜 판단을 해 개발자가 힌트를 사용해 도움을 줄 수 있다.**
  - 이를 확인하는 쿼리도 있다.
- **쿼리 실행기**
  - 옵티마이저가 결정한 계획에 따라 스토리지 엔진에 요청함
    - 이때 Handler API 를 사용
  - 스토리지 엔진에 요청하는 것을 handler 요청 이라고 함


- **스토리지 엔진**
  - 디스크에서 데이터를 가져오거나 저장하는 역할
  - MySQL 스토리지 엔진은 플러그인 형태로 Handler API만 맞춘다면 직접 구현해서 사용할 수 있다.
  - InnoDB, MyIsam 등 여러개의 스토리지 엔진이 존재
  - 8.0 대 부터는 InnoDB 엔진을 디폴트
    - InnoDb의 핵심 키워드 3가지
      - Clustered Index
      - Redo - Undo
      - Buffer pool

## 쿼리캐시가 주는 인사이트 
- MySQL 5.0 까지는 쿼리 캐시라는 것이 있었음 
- 8.0 대에 들어와서는 쿼리 캐시는 폐기됨
- **SQL 과 데이터를 매핑해서 똑같은 SQL을 요청하면 똑같은 데이터를 캐싱해서 주는 것**
  - **만약 데이터를 변경되면 캐싱된 데이터를 변경할 때 락과 같은 문제가 일어나서 폐기 되었다.**

---
하지만 오라클에는 소프트 파싱, 하드 파싱이 있음
- **소프트 파싱** : SQL, 실행계획을 캐시에서 찾아 **옵티마이저 과정을 생략**후 실행단계로 넘어감
- **하드 파싱** : SQL, 실행계획을 캐시에서 찾지 못해 옵티마이저 과정을 거치고나서 실행단계로 넘어감

---

### 쿼리캐시가 주는 인사이트 정리
- MySQL에는 소프트 파싱이 없다.
- 하지만 5 버전까지는 쿼리 캐시가 있었음
- 쿼리 캐시는 SQL에 해당하는 데이터를 저장하는 것
- **쿼리 캐시는 데이터를 캐시하기 때문에**
  - **-> 테이블의 데이터가 변경되면 캐시의 데이터도 함께 갱신 시켜줘야함**

<br/>


- Oracle에는 소프트 파싱이 존재
- 실행계획까지만 캐싱
- 하지만 모든 SQL과 맵핑해 데이터까지는 캐싱하지는 않음 (힌트가 설정으로 가능하긴 함)

<br/>


- MySQL의 쿼리캐시, Oracle의 소프트 파싱 모두 성능 최적화를 위해 캐시라는 기술을 도입한 사례
- **그러나 캐시의 범위가 다르다**
- 캐시를 도입할 때는 항상 만료 정책을 고려함 
- 쿼리캐시는 소프트 파싱에 비해 조회 성능은 더 높지만 캐시 데이터 관리에 더 높은 비용이 들어감

> **모든 기술은 트레이드 오프다!**
> **조회와 성능 사이에 밸런스를 어떻게 맞출지 정하는 것!**
> 
> 쿼리 캐시는 조회에 가중치를 많이 둔 반면,
> 
> 소프트 파싱은 성능에도 가중치를 준 느낌
> 
> A 라는 장점이 있으면 B라는 단점이 있고, 
> 이를 결정하고 고민하는게 중요하다! 

